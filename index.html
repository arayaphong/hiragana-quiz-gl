<!DOCTYPE html>
<html lang="th">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hiragana Quiz GL</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #1a202c;
        }

        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
            cursor: grab;
        }

        canvas:active {
            cursor: grabbing;
        }

        .info {
            position: absolute;
            top: 20px;
            left: 20px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 15px;
            border-radius: 8px;
            font-family: 'Inter', sans-serif;
            font-size: 14px;
        }
    </style>
</head>

<body class="flex items-center justify-center h-screen">
    <canvas id="glCanvas"></canvas>
    <div class="info">
        <p>3D Hiragana Learning Game (OOP)</p>
        <p>Drag to rotate • Scroll to zoom</p>
        <p>Middle-click to reset view</p>
    </div>

    <script id="vertex-shader-3d" type="x-shader/x-vertex">
        attribute vec3 a_vertexPosition;
        attribute vec2 a_textureCoord;
        uniform mat4 u_modelViewMatrix;
        uniform mat4 u_projectionMatrix;
        varying vec2 v_textureCoord;
        void main() {
            v_textureCoord = a_textureCoord;
            gl_Position = u_projectionMatrix * u_modelViewMatrix * vec4(a_vertexPosition, 1.0);
        }
    </script>

    <script id="fragment-shader-3d" type="x-shader/x-fragment">
        precision mediump float;
        uniform sampler2D u_textTexture;
        uniform bool u_useTexture;
        uniform vec4 u_solidColor;
        varying vec2 v_textureCoord;
        void main() {
            if (u_useTexture) {
                vec4 textColor = texture2D(u_textTexture, v_textureCoord);
                gl_FragColor = textColor;
            } else {
                gl_FragColor = u_solidColor;
            }
        }
    </script>

    <script>
        // ===============================
        // UTILITY CLASSES
        // ===============================

        class Mat4 {
            static create() {
                return new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
            }

            static identity(out) {
                out.set([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
                return out;
            }

            static copy(out, a) {
                out.set(a);
                return out;
            }

            static multiply(out, a, b) {
                let a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
                let a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
                let a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
                let a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

                let b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
                out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
                out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
                out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
                out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

                b0 = b[4]; b1 = b[5]; b2 = b[6]; b3 = b[7];
                out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
                out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
                out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
                out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

                b0 = b[8]; b1 = b[9]; b2 = b[10]; b3 = b[11];
                out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
                out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
                out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
                out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

                b0 = b[12]; b1 = b[13]; b2 = b[14]; b3 = b[15];
                out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
                out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
                out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
                out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
                return out;
            }

            static translate(out, a, v) {
                let x = v[0], y = v[1], z = v[2];
                out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
                out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
                out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
                out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
                return out;
            }

            static rotateX(out, a, rad) {
                const s = Math.sin(rad), c = Math.cos(rad);
                const a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
                const a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
                out[0] = a[0]; out[1] = a[1]; out[2] = a[2]; out[3] = a[3];
                out[4] = a10 * c + a20 * s; out[5] = a11 * c + a21 * s; out[6] = a12 * c + a22 * s; out[7] = a13 * c + a23 * s;
                out[8] = a20 * c - a10 * s; out[9] = a21 * c - a11 * s; out[10] = a22 * c - a12 * s; out[11] = a23 * c - a13 * s;
                out[12] = a[12]; out[13] = a[13]; out[14] = a[14]; out[15] = a[15];
                return out;
            }

            static rotateY(out, a, rad) {
                const s = Math.sin(rad), c = Math.cos(rad);
                const a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
                const a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
                out[0] = a00 * c - a20 * s; out[1] = a01; out[2] = a02; out[3] = a03;
                out[4] = a[4]; out[5] = a[5]; out[6] = a[6]; out[7] = a[7];
                out[8] = a00 * s + a20 * c; out[9] = a21; out[10] = a22; out[11] = a23;
                out[12] = a[12]; out[13] = a[13]; out[14] = a[14]; out[15] = a[15];
                return out;
            }

            static orthogonal(out, left, right, bottom, top, near, far) {
                out[0] = 2 / (right - left);
                out[1] = 0;
                out[2] = 0;
                out[3] = 0;
                out[4] = 0;
                out[5] = 2 / (top - bottom);
                out[6] = 0;
                out[7] = 0;
                out[8] = 0;
                out[9] = 0;
                out[10] = -2 / (far - near);
                out[11] = 0;
                out[12] = -(right + left) / (right - left);
                out[13] = -(top + bottom) / (top - bottom);
                out[14] = -(far + near) / (far - near);
                out[15] = 1;
                return out;
            }
        }

        // ===============================
        // SHADER MANAGER
        // ===============================

        class ShaderManager {
            constructor(gl) {
                this.gl = gl;
                this.programs = new Map();
                this.uniforms = new Map();
                this.attributes = new Map();
            }

            createShader(type, source) {
                const shader = this.gl.createShader(type);
                this.gl.shaderSource(shader, source);
                this.gl.compileShader(shader);

                if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
                    console.error("Shader compile error:", this.gl.getShaderInfoLog(shader));
                    this.gl.deleteShader(shader);
                    return null;
                }
                return shader;
            }

            createProgram(name, vertexSource, fragmentSource) {
                const vertexShader = this.createShader(this.gl.VERTEX_SHADER, vertexSource);
                const fragmentShader = this.createShader(this.gl.FRAGMENT_SHADER, fragmentSource);

                if (!vertexShader || !fragmentShader) return false;

                const program = this.gl.createProgram();
                this.gl.attachShader(program, vertexShader);
                this.gl.attachShader(program, fragmentShader);
                this.gl.linkProgram(program);

                if (!this.gl.getProgramParameter(program, this.gl.LINK_STATUS)) {
                    console.error("Program link error:", this.gl.getProgramInfoLog(program));
                    return false;
                }

                this.programs.set(name, program);
                this.cacheLocations(name, program);
                return true;
            }

            cacheLocations(name, program) {
                const uniforms = {
                    projectionMatrix: this.gl.getUniformLocation(program, "u_projectionMatrix"),
                    modelViewMatrix: this.gl.getUniformLocation(program, "u_modelViewMatrix"),
                    textTexture: this.gl.getUniformLocation(program, "u_textTexture"),
                    useTexture: this.gl.getUniformLocation(program, "u_useTexture"),
                    solidColor: this.gl.getUniformLocation(program, "u_solidColor")
                };

                const attributes = {
                    vertexPosition: this.gl.getAttribLocation(program, "a_vertexPosition"),
                    textureCoord: this.gl.getAttribLocation(program, "a_textureCoord")
                };

                this.uniforms.set(name, uniforms);
                this.attributes.set(name, attributes);
            }

            useProgram(name) {
                const program = this.programs.get(name);
                if (program) {
                    this.gl.useProgram(program);
                    return {
                        uniforms: this.uniforms.get(name),
                        attributes: this.attributes.get(name)
                    };
                }
                return null;
            }

            cleanup() {
                this.programs.forEach(program => this.gl.deleteProgram(program));
                this.programs.clear();
                this.uniforms.clear();
                this.attributes.clear();
            }
        }

        // ===============================
        // TEXTURE MANAGER
        // ===============================

        class TextureManager {
            constructor(gl) {
                this.gl = gl;
                this.textures = new Map();
            }

            createHiraganaTextures(characters = ['か', 'き', 'く', 'け', 'こ']) {
                const textures = [];

                characters.forEach((char, index) => {
                    const canvas = document.createElement('canvas');
                    canvas.width = 512;
                    canvas.height = 512;
                    const ctx = canvas.getContext('2d');

                    // Clear background
                    ctx.clearRect(0, 0, canvas.width, canvas.height);

                    // Text styling
                    ctx.font = 'bold 300px serif';
                    ctx.fillStyle = 'white';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';

                    // Text shadow
                    ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
                    ctx.shadowBlur = 8;
                    ctx.shadowOffsetX = 4;
                    ctx.shadowOffsetY = 4;

                    // Draw character
                    ctx.fillText(char, canvas.width / 2, canvas.height / 2);

                    // Create WebGL texture
                    const texture = this.gl.createTexture();
                    this.gl.bindTexture(this.gl.TEXTURE_2D, texture);
                    this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, canvas);

                    // Set texture parameters
                    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
                    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);
                    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);
                    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);

                    textures.push(texture);
                    this.textures.set(`hiragana_${index}`, texture);
                });

                return textures;
            }

            getTexture(name) {
                return this.textures.get(name);
            }

            cleanup() {
                this.textures.forEach(texture => this.gl.deleteTexture(texture));
                this.textures.clear();
            }
        }

        // ===============================
        // GEOMETRY MANAGER
        // ===============================

        class GeometryManager {
            constructor(gl) {
                this.gl = gl;
                this.buffers = new Map();
                this.geometries = new Map();
            }

            createRoundedPlane(size = 2.0, thickness = 0.3, cornerRadius = 0.4, segments = 32) {
                const halfThickness = thickness / 2;
                const vertices = [];
                const texCoords = [];
                const halfW = size / 2;
                const halfH = size / 2;

                // Center vertex
                vertices.push(0, 0, halfThickness);
                texCoords.push(0.5, 0.5);

                // Create rounded outline
                for (let i = 0; i <= segments; i++) {
                    const t = (i / segments) * Math.PI * 2;
                    let x, y;

                    if (t >= 0 && t < Math.PI / 2) {
                        const cornerX = halfW - cornerRadius;
                        const cornerY = halfH - cornerRadius;
                        x = cornerX + cornerRadius * Math.cos(t);
                        y = cornerY + cornerRadius * Math.sin(t);
                    } else if (t >= Math.PI / 2 && t < Math.PI) {
                        const cornerX = -halfW + cornerRadius;
                        const cornerY = halfH - cornerRadius;
                        x = cornerX + cornerRadius * Math.cos(t);
                        y = cornerY + cornerRadius * Math.sin(t);
                    } else if (t >= Math.PI && t < 3 * Math.PI / 2) {
                        const cornerX = -halfW + cornerRadius;
                        const cornerY = -halfH + cornerRadius;
                        x = cornerX + cornerRadius * Math.cos(t);
                        y = cornerY + cornerRadius * Math.sin(t);
                    } else {
                        const cornerX = halfW - cornerRadius;
                        const cornerY = -halfH + cornerRadius;
                        x = cornerX + cornerRadius * Math.cos(t);
                        y = cornerY + cornerRadius * Math.sin(t);
                    }

                    vertices.push(x, y, halfThickness);
                    const u = (x + halfW) / size;
                    const v = 1.0 - (y + halfH) / size;
                    texCoords.push(u, v);
                }

                // Create back face
                const frontVertexCount = vertices.length / 3;
                for (let i = 0; i < frontVertexCount; i++) {
                    vertices.push(vertices[i * 3], vertices[i * 3 + 1], -halfThickness);
                }

                return this.createGeometryBuffers(vertices, texCoords, segments);
            }

            createGeometryBuffers(vertices, texCoords, segments) {
                const outlineVertexCount = segments + 1;

                // Front face indices
                const frontIndices = [];
                for (let i = 1; i <= outlineVertexCount; i++) {
                    const next = (i % outlineVertexCount) + 1;
                    frontIndices.push(0, i, next);
                }

                // Other faces indices
                const otherIndices = [];
                const backStartIndex = outlineVertexCount + 1;

                // Back face
                for (let i = 1; i <= outlineVertexCount; i++) {
                    const next = (i % outlineVertexCount) + 1;
                    const backIdx = backStartIndex + i;
                    const backNextIdx = backStartIndex + next;
                    otherIndices.push(backStartIndex, backNextIdx, backIdx);
                }

                // Side faces
                for (let i = 1; i <= outlineVertexCount; i++) {
                    const next = (i % outlineVertexCount) + 1;
                    const backCurrent = backStartIndex + i;
                    const backNext = backStartIndex + next;
                    otherIndices.push(i, backCurrent, next);
                    otherIndices.push(next, backCurrent, backNext);
                }

                // Wireframe
                const wireframeVertices = [];
                for (let i = 1; i <= outlineVertexCount; i++) {
                    const next = (i % outlineVertexCount) + 1;
                    const currentIdx = i * 3;
                    const nextIdx = next * 3;

                    // Front outline
                    wireframeVertices.push(
                        vertices[currentIdx], vertices[currentIdx + 1], vertices[currentIdx + 2],
                        vertices[nextIdx], vertices[nextIdx + 1], vertices[nextIdx + 2]
                    );

                    // Back outline
                    wireframeVertices.push(
                        vertices[currentIdx], vertices[currentIdx + 1], -vertices[currentIdx + 2],
                        vertices[nextIdx], vertices[nextIdx + 1], -vertices[nextIdx + 2]
                    );
                }

                // Connecting edges
                const connectionStep = Math.floor(outlineVertexCount / 8);
                for (let i = 1; i <= outlineVertexCount; i += connectionStep) {
                    const idx = i * 3;
                    wireframeVertices.push(
                        vertices[idx], vertices[idx + 1], vertices[idx + 2],
                        vertices[idx], vertices[idx + 1], -vertices[idx + 2]
                    );
                }

                return {
                    vertices: new Float32Array(vertices),
                    texCoords: new Float32Array(texCoords),
                    frontIndices: new Uint16Array(frontIndices),
                    otherIndices: new Uint16Array(otherIndices),
                    wireframeVertices: new Float32Array(wireframeVertices)
                };
            }

            createBuffers(name, geometry) {
                const buffers = {
                    vertices: this.gl.createBuffer(),
                    texCoords: this.gl.createBuffer(),
                    frontIndices: this.gl.createBuffer(),
                    otherIndices: this.gl.createBuffer(),
                    wireframe: this.gl.createBuffer()
                };

                // Vertex buffer
                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, buffers.vertices);
                this.gl.bufferData(this.gl.ARRAY_BUFFER, geometry.vertices, this.gl.STATIC_DRAW);

                // Texture coordinate buffer
                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, buffers.texCoords);
                this.gl.bufferData(this.gl.ARRAY_BUFFER, geometry.texCoords, this.gl.STATIC_DRAW);

                // Front indices
                this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, buffers.frontIndices);
                this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, geometry.frontIndices, this.gl.STATIC_DRAW);

                // Other indices
                this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, buffers.otherIndices);
                this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, geometry.otherIndices, this.gl.STATIC_DRAW);

                // Wireframe
                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, buffers.wireframe);
                this.gl.bufferData(this.gl.ARRAY_BUFFER, geometry.wireframeVertices, this.gl.STATIC_DRAW);

                const geometryData = {
                    buffers,
                    frontIndexCount: geometry.frontIndices.length,
                    otherIndexCount: geometry.otherIndices.length,
                    wireframeVertexCount: geometry.wireframeVertices.length / 3
                };

                this.buffers.set(name, buffers);
                this.geometries.set(name, geometryData);

                return geometryData;
            }

            getGeometry(name) {
                return this.geometries.get(name);
            }

            cleanup() {
                this.buffers.forEach(bufferSet => {
                    Object.values(bufferSet).forEach(buffer => this.gl.deleteBuffer(buffer));
                });
                this.buffers.clear();
                this.geometries.clear();
            }
        }

        // ===============================
        // CAMERA CONTROLLER
        // ===============================

        class CameraController {
            constructor(canvas) {
                this.canvas = canvas;
                this.rotationX = 0;
                this.rotationY = 0;
                this.zoom = 7.0;
                this.projectionMatrix = Mat4.create();
                this.viewMatrix = Mat4.create();

                this.updateProjectionMatrix();
            }

            updateProjectionMatrix() {
                const aspect = this.canvas.clientWidth / this.canvas.clientHeight;
                const size = this.zoom;
                const left = -size * aspect;
                const right = size * aspect;
                const bottom = -size;
                const top = size;
                const near = -10;
                const far = 10;

                Mat4.orthogonal(this.projectionMatrix, left, right, bottom, top, near, far);
            }

            updateViewMatrix() {
                Mat4.identity(this.viewMatrix);
                Mat4.rotateX(this.viewMatrix, this.viewMatrix, this.rotationX);
                Mat4.rotateY(this.viewMatrix, this.viewMatrix, this.rotationY);
            }

            setRotation(x, y) {
                this.rotationX = Math.max(-Math.PI / 3, Math.min(Math.PI / 3, x));
                this.rotationY = y;
                this.updateViewMatrix();
            }

            setZoom(zoom) {
                this.zoom = Math.max(0.5, Math.min(10, zoom));
                this.updateProjectionMatrix();
            }

            reset() {
                this.rotationX = 0;
                this.rotationY = 0;
                this.zoom = 7.0;
                this.updateProjectionMatrix();
                this.updateViewMatrix();
            }

            handleResize() {
                this.updateProjectionMatrix();
            }
        }

        // ===============================
        // INPUT HANDLER
        // ===============================

        class InputHandler {
            constructor(canvas, camera) {
                this.canvas = canvas;
                this.camera = camera;
                this.mouseDown = false;
                this.lastMouseX = null;
                this.lastMouseY = null;

                this.setupEventListeners();
            }

            setupEventListeners() {
                this.canvas.addEventListener('mousedown', this.onMouseDown.bind(this));
                this.canvas.addEventListener('wheel', this.onWheel.bind(this));
                this.canvas.addEventListener('auxclick', this.onAuxClick.bind(this));

                document.addEventListener('mouseup', this.onMouseUp.bind(this));
                document.addEventListener('mousemove', this.onMouseMove.bind(this));
            }

            onMouseDown(event) {
                if (event.button === 0) { // Left mouse button
                    this.mouseDown = true;
                    this.lastMouseX = event.clientX;
                    this.lastMouseY = event.clientY;
                } else if (event.button === 1) { // Middle mouse button
                    event.preventDefault();
                    this.camera.reset();
                }
            }

            onMouseUp() {
                this.mouseDown = false;
            }

            onMouseMove(event) {
                if (!this.mouseDown) return;

                const deltaX = event.clientX - this.lastMouseX;
                const deltaY = event.clientY - this.lastMouseY;
                const sensitivity = 0.01;

                const newRotationY = this.camera.rotationY + deltaX * sensitivity;
                const newRotationX = this.camera.rotationX + deltaY * sensitivity;

                this.camera.setRotation(newRotationX, newRotationY);

                this.lastMouseX = event.clientX;
                this.lastMouseY = event.clientY;
            }

            onWheel(event) {
                event.preventDefault();
                const zoomSpeed = 0.001;
                const newZoom = this.camera.zoom + event.deltaY * zoomSpeed;
                this.camera.setZoom(newZoom);
            }

            onAuxClick(event) {
                if (event.button === 1) { // Middle mouse button
                    event.preventDefault();
                    this.camera.reset();
                }
            }
        }

        // ===============================
        // ANIMATION CONTROLLER
        // ===============================

        class AnimationController {
            constructor() {
                this.time = 0;
                this.swingAmplitude = Math.PI / 6;
                this.swingFrequency = 0.03;
                this.objectMatrices = Array(5).fill().map(() => Mat4.create());
                this.swingMatrix = Mat4.create();
            }

            update(deltaTime) {
                this.time += deltaTime;
            }

            getObjectMatrix(index, baseMatrix, spacing = 2.8) {
                const objectMatrix = this.objectMatrices[index];
                Mat4.copy(objectMatrix, baseMatrix);

                // Position in line
                const startOffset = -2 * spacing;
                const xOffset = startOffset + index * spacing;
                Mat4.translate(objectMatrix, objectMatrix, [xOffset, 0, 0]);

                // Individual swing animation
                const phaseOffset = index * Math.PI / 2.5;
                const swingAngle = this.swingAmplitude * Math.sin(this.swingFrequency * this.time * 100 + phaseOffset);

                Mat4.identity(this.swingMatrix);
                Mat4.rotateY(this.swingMatrix, this.swingMatrix, swingAngle);
                Mat4.multiply(objectMatrix, objectMatrix, this.swingMatrix);

                return objectMatrix;
            }
        }

        // ===============================
        // WEBGL RENDERER
        // ===============================

        class WebGLRenderer {
            constructor(canvas) {
                this.canvas = canvas;
                this.gl = null;
                this.init();
            }

            init() {
                this.gl = this.canvas.getContext("webgl") || this.canvas.getContext("experimental-webgl");
                if (!this.gl) {
                    throw new Error("WebGL not supported");
                }

                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);

                this.gl.enable(this.gl.DEPTH_TEST);
                this.gl.depthFunc(this.gl.LEQUAL);
                this.gl.enable(this.gl.BLEND);
                this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);

                return true;
            }

            clear() {
                this.gl.clearColor(0.1, 0.125, 0.176, 1.0);
                this.gl.clearDepth(1.0);
                this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
            }

            handleResize() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
            }

            bindVertexBuffer(buffer, attributeLocation, size = 3) {
                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, buffer);
                this.gl.vertexAttribPointer(attributeLocation, size, this.gl.FLOAT, false, 0, 0);
                this.gl.enableVertexAttribArray(attributeLocation);
            }

            drawElements(indexBuffer, count, mode = this.gl.TRIANGLES) {
                this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
                this.gl.drawElements(mode, count, this.gl.UNSIGNED_SHORT, 0);
            }

            drawArrays(count, mode = this.gl.LINES) {
                this.gl.drawArrays(mode, 0, count);
            }

            cleanup() {
                // WebGL context cleanup is handled by browser
            }
        }

        // ===============================
        // MAIN GAME CLASS
        // ===============================

        class HiraganaGame {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.renderer = new WebGLRenderer(this.canvas);
                this.gl = this.renderer.gl;

                this.shaderManager = new ShaderManager(this.gl);
                this.textureManager = new TextureManager(this.gl);
                this.geometryManager = new GeometryManager(this.gl);
                this.camera = new CameraController(this.canvas);
                this.inputHandler = new InputHandler(this.canvas, this.camera);
                this.animationController = new AnimationController();

                this.characters = ['か', 'き', 'く', 'け', 'こ'];
                this.running = false;

                this.init();
            }

            async init() {
                try {
                    // Initialize shaders
                    const vertexSource = document.getElementById("vertex-shader-3d").textContent;
                    const fragmentSource = document.getElementById("fragment-shader-3d").textContent;

                    if (!this.shaderManager.createProgram("main", vertexSource, fragmentSource)) {
                        throw new Error("Failed to create shader program");
                    }

                    // Create textures
                    this.textures = this.textureManager.createHiraganaTextures(this.characters);

                    // Create geometry
                    const geometry = this.geometryManager.createRoundedPlane();
                    this.geometryData = this.geometryManager.createBuffers("plane", geometry);

                    // Setup resize handler
                    window.addEventListener('resize', this.handleResize.bind(this));

                    console.log("HiraganaGame initialized successfully");
                    this.start();

                } catch (error) {
                    console.error("Failed to initialize game:", error);
                }
            }

            handleResize() {
                this.renderer.handleResize();
                this.camera.handleResize();
            }

            start() {
                if (this.running) return;
                this.running = true;
                this.lastTime = performance.now();
                this.render();
            }

            stop() {
                this.running = false;
            }

            render(currentTime = performance.now()) {
                if (!this.running) return;

                const deltaTime = (currentTime - this.lastTime) * 0.001;
                this.lastTime = currentTime;

                // Update animations
                this.animationController.update(deltaTime);
                this.camera.updateViewMatrix();

                // Clear screen
                this.renderer.clear();

                // Use shader program
                const { uniforms, attributes } = this.shaderManager.useProgram("main");

                // Set projection matrix
                this.gl.uniformMatrix4fv(uniforms.projectionMatrix, false, this.camera.projectionMatrix);

                // Render each hiragana object
                for (let i = 0; i < this.characters.length; i++) {
                    const objectMatrix = this.animationController.getObjectMatrix(i, this.camera.viewMatrix);
                    this.gl.uniformMatrix4fv(uniforms.modelViewMatrix, false, objectMatrix);

                    this.renderObject(i, uniforms, attributes);
                }

                requestAnimationFrame(this.render.bind(this));
            }

            renderObject(index, uniforms, attributes) {
                const { buffers } = this.geometryData;

                // === FRONT FACE WITH TEXTURE ===
                this.gl.uniform1i(uniforms.useTexture, 1);
                this.gl.activeTexture(this.gl.TEXTURE0);
                this.gl.bindTexture(this.gl.TEXTURE_2D, this.textures[index]);
                this.gl.uniform1i(uniforms.textTexture, 0);

                this.renderer.bindVertexBuffer(buffers.vertices, attributes.vertexPosition, 3);
                this.renderer.bindVertexBuffer(buffers.texCoords, attributes.textureCoord, 2);
                this.renderer.drawElements(buffers.frontIndices, this.geometryData.frontIndexCount);

                // === OTHER FACES WITH SOLID COLOR ===
                this.gl.uniform1i(uniforms.useTexture, 0);
                this.gl.uniform4f(uniforms.solidColor, 0.4, 0.4, 0.5, 1.0);
                this.gl.disableVertexAttribArray(attributes.textureCoord);

                this.renderer.drawElements(buffers.otherIndices, this.geometryData.otherIndexCount);

                // === WIREFRAME ===
                this.gl.uniform4f(uniforms.solidColor, 1.0, 1.0, 1.0, 1.0);
                this.renderer.bindVertexBuffer(buffers.wireframe, attributes.vertexPosition, 3);
                this.renderer.drawArrays(this.geometryData.wireframeVertexCount);
            }

            cleanup() {
                this.stop();
                this.shaderManager.cleanup();
                this.textureManager.cleanup();
                this.geometryManager.cleanup();
                this.renderer.cleanup();
            }
        }

        // ===============================
        // INITIALIZATION
        // ===============================

        let game;

        document.addEventListener('DOMContentLoaded', () => {
            try {
                game = new HiraganaGame('glCanvas');
            } catch (error) {
                console.error("Failed to start game:", error);
                alert("Failed to initialize WebGL game. Please check browser compatibility.");
            }
        });

        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            if (game) {
                game.cleanup();
            }
        });
    </script>
</body>

</html>